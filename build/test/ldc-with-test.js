// Generated by CoffeeScript 1.9.2
(function(_oG) {
/*! Ldc 0.0.5 //// MIT Licence //// http://ldc.richplastow.com/ */
var Item, Ldc, Tudor, _o, _oT, _oV, tudor,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_oT = 'Ldc';

_oV = '0.0.5';

_o = {};

Item = (function() {
  Item.prototype.C = 'Item';

  Item.prototype.toString = function() {
    return '[object Item]';
  };

  function Item(config) {
    var M, v;
    if (config == null) {
      config = {};
    }
    M = "/ldc/src/Item.litcoffee Item()\n  ";
    v = _o.validator(M + 'config.', config);
    this.uid = v('uid <string ^[a-z]\\w{1,23}$>');
    this.index = v('index <integer 0-9999>');
  }

  Item.prototype.xx = function(yy) {
    var M;
    return M = "/ldc/src/Item.litcoffee Item::xx()\n  ";
  };

  return Item;

})();

Ldc = (function() {
  Ldc.prototype.C = 'Ldc';

  Ldc.prototype.toString = function() {
    return '[object Ldc]';
  };

  function Ldc(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = "/ldc/src/Ldc.litcoffee Ldc()\n  ";
    this.items = [];
  }

  Ldc.prototype.addItem = function(kind, config, uid) {
    var M, item, kinds, v;
    M = "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  ";
    kinds = {
      Hat: Item.Hit.Hat,
      Sine: Item.Tone.Sine
    };
    v = _o.validator(M + 'argument ', {
      kind: kind,
      config: config,
      uid: uid
    });
    kind = v('kind <string ^' + Object.keys(kinds).join('$|^') + '$>');
    config = v('config <object>', {});
    uid = v('uid <string ^[a-z]\\w{1,23}$>', _o.uid(kind.toLowerCase()));
    config.uid = uid;
    config.index = this.items.length;
    item = new kinds[kind](config);
    this.items.push(item);
    return uid;
  };

  Ldc.prototype.xx = function(yy) {
    var M;
    return M = "/ldc/src/Ldc.litcoffee Ldc::xx()\n  ";
  };

  return Ldc;

})();

Ldc.xx = function(yy) {
  var M;
  return M = "/ldc/src/Ldc.litcoffee Ldc.xx()\n  ";
};

if ('undefined' === typeof console || !console.log) {
  _o = function() {};
} else if ('object' === typeof console.log) {
  _o = Function.prototype.bind(console.log, console);
} else {
  _o = console.log.bind(console);
}

_o.A = 'array';

_o.B = 'boolean';

_o.D = 'document';

_o.E = 'error';

_o.F = 'function';

_o.I = 'integer';

_o.N = 'number';

_o.O = 'object';

_o.R = 'regexp';

_o.S = 'string';

_o.U = 'undefined';

_o.X = 'null';

_o.G = _oG;

_o.T = _oT;

_o.V = _oV;

_o.is = function(c, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (c) {
    return t;
  } else {
    return f;
  }
};

_o.isU = function(x) {
  return _o.U === typeof x;
};

_o.isX = function(x) {
  return null === x;
};

_o.type = function(a) {
  var ta;
  if (_o.isX(a)) {
    return _o.X;
  }
  ta = typeof a;
  if ({
    undefined: 1,
    string: 1,
    number: 1,
    boolean: 1
  }[ta]) {
    return ta;
  }
  if (!a.nodeName && a.constructor !== Array && /function/i.test('' + a)) {
    return _o.F;
  }
  return {}.toString.call(a).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
};

_o.ex = function(x, a, b) {
  var pos;
  if (-1 === (pos = a.indexOf(x))) {
    return x;
  } else {
    return b.charAt(pos);
  }
};

_o.has = function(h, n, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (-1 !== h.indexOf(n)) {
    return t;
  } else {
    return f;
  }
};

_o.uid = function(p) {
  return (p || '') + '_' + (Math.random() + '1111111111111111').slice(2, 18);
};

_o.insert = function(basis, overlay, offset) {
  return basis.slice(0, offset) + overlay + basis.slice(offset + overlay.length);
};

_o.redefine = function(obj, name, value, kind) {
  switch (kind) {
    case 'constant':
      return Object.defineProperty(obj, name, {
        value: value,
        enumerable: true
      });
    case 'private':
      return Object.defineProperty(obj, name, {
        value: value,
        enumerable: false
      });
  }
};

_o.validator = function(M, obj) {
  return function(signature, fallback) {
    var j, key, len, matches, max, min, ref, ref1, rule, tv, type, types, value;
    matches = signature.match(/^([_a-z][_a-z0-9]*)\s+<([|a-z]+)\s*(.*)>$/);
    if (!matches) {
      throw RangeError("/jsmultrun/src/_o-helpers.litcoffee _o.valid()\n  signature " + signature + " is invalid");
    }
    signature = matches[0], key = matches[1], types = matches[2], rule = matches[3];
    value = obj[key];
    tv = _o.type(value);
    if (_o.U === tv) {
      if (2 === arguments.length) {
        return fallback;
      }
      throw TypeError(M + key + " is undefined and has no fallback");
    }
    ref = types.split('|');
    for (j = 0, len = ref.length; j < len; j++) {
      type = ref[j];
      if ((_o.N === type || _o.I === type) && _o.N === tv) {
        if (_o.I === type && value % 1) {
          throw RangeError(M + key + " is a number but not an integer");
        }
        if (rule) {
          ref1 = rule.split('-'), min = ref1[0], max = ref1[1];
          if (value < min || value > max) {
            throw RangeError(M + key + (" is " + value + " (must be " + rule + ")"));
          }
        }
        return value;
      }
      if (type === tv) {
        if (_o.S === tv && rule) {
          if (!RegExp(rule).test(value)) {
            throw RangeError(M + key + (" fails " + rule));
          }
        }
        return value;
      }
    }
    throw TypeError(M + key + (" is type " + tv + " not " + types));
  };
};

if (_o.F === typeof define && define.amd) {
  define(function() {
    return Ldc;
  });
} else if (_o.O === typeof module && module && module.exports) {
  module.exports = Ldc;
} else {
  _o.G.Ldc = Ldc;
}

Item.Hit = (function(superClass) {
  extend(Hit, superClass);

  Hit.prototype.C = 'Item.Hit';

  Hit.prototype.toString = function() {
    return '[object Item.Hit]';
  };

  function Hit(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = "/ldc/src/Item/Hit.litcoffee Item.Hit()\n  ";
    Hit.__super__.constructor.call(this, config);
    this.x = null;
  }

  Hit.prototype.xx = function(yy) {
    var M;
    return M = "/ldc/src/Item/Hit.litcoffee Item.Hit::xx()\n  ";
  };

  return Hit;

})(Item);

Item.Tone = (function(superClass) {
  extend(Tone, superClass);

  Tone.prototype.C = 'Item.Tone';

  Tone.prototype.toString = function() {
    return '[object Item.Tone]';
  };

  function Tone(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = "/ldc/src/Item/Tone.litcoffee Item.Tone()\n  ";
    Tone.__super__.constructor.call(this, config);
    this.x = null;
  }

  Tone.prototype.xx = function(yy) {
    var M;
    return M = "/ldc/src/Item/Tone.litcoffee Item.Tone::xx()\n  ";
  };

  return Tone;

})(Item);

Item.Hit.Hat = (function(superClass) {
  extend(Hat, superClass);

  Hat.prototype.C = 'Item.Hit.Hat';

  Hat.prototype.toString = function() {
    return '[object Item.Hit.Hat]';
  };

  function Hat(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = "/ldc/src/Item/Hit/Hat.litcoffee Item.Hit.Hat()\n  ";
    Hat.__super__.constructor.call(this, config);
    this.x = null;
  }

  Hat.prototype.xx = function(yy) {
    var M;
    return M = "/ldc/src/Item/Hit/Hat.litcoffee Item.Hit.Hat::xx()\n  ";
  };

  return Hat;

})(Item.Hit);

Item.Tone.Sine = (function(superClass) {
  extend(Sine, superClass);

  Sine.prototype.C = 'Item.Tone.Sine';

  Sine.prototype.toString = function() {
    return '[object Item.Tone.Sine]';
  };

  function Sine(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = "/ldc/src/Item/Tone/Sine.litcoffee Item.Tone.Sine()\n  ";
    Sine.__super__.constructor.call(this, config);
    this.x = null;
  }

  Sine.prototype.xx = function(yy) {
    var M;
    return M = "/ldc/src/Item/Tone/Sine.litcoffee Item.Tone.Sine::xx()\n  ";
  };

  return Sine;

})(Item.Tone);

Tudor = (function() {
  Tudor.prototype.I = 'Tudor';

  Tudor.prototype.toString = function() {
    return "[object " + I + "]";
  };

  Tudor.prototype.articles = [];

  function Tudor(opt) {
    this.opt = opt != null ? opt : {};
    this["do"] = bind(this["do"], this);
    switch (this.opt.format) {
      case 'html':
        this.pageHead = function(summary) {
          return "<style>\n  body     { font-family: sans-serif; }\n  a        { outline: 0; }\n  b        { display: inline-block; width: .7em }\n\n  b.pass              { color: #393 }\n  b.fail              { color: #bbb }\n  article.fail b.pass { color: #bbb }\n  section.fail b.pass { color: #bbb }\n\n  pre      { padding: .5em; margin: .2em 0; border-radius: 4px; }\n  pre.fn   { background-color: #fde }\n  pre.pass { background-color: #cfc }\n  pre.fail { background-color: #d8e0e8 }\n\n  article  { margin-bottom: .5rem }\n  article h2 { padding-left:.5rem; margin:0; font-weight:normal }\n  article.pass { border-left: 5px solid #9c9 }\n  article.fail { border-left: 5px solid #9bf }\n  article.fail h2 { margin-bottom: .5rem }\n  article.pass >div { display: none }\n\n  section  { margin-bottom: .5rem }\n  section h3   { padding-left: .5rem; margin: 0; }\n  section.pass { border-left: 3px solid #9c9 }\n  section.fail { border-left: 3px solid #9bf }\n  section.fail h3 { margin-bottom: .5rem }\n  section.pass >div { display: none }\n\n  article.fail section.pass { border-left-color: #ccc }\n\n  div      { padding-left: .5em; }\n  div.fail { border-left: 3px solid #9bf; font-size: .8rem }\n  div h4   { margin: 0 }\n  div h4 { font: normal .8rem/1.2rem monaco, monospace }\n  div.fail, div.fail h4 { margin: .5rem 0 }\n\n</style>\n<h4><a href=\"#end\" id=\"top\">\u2b07</a>  " + summary + "</h4>";
        };
        this.pageFoot = function(summary) {
          return "<h4><a href=\"#top\" id=\"end\">\u2b06</a>  " + summary + "</h4>\n<script>\n  document.title='" + (summary.replace(/<\/?[^>]+>/g, '')) + "';\n</script>";
        };
        this.articleHead = function(heading, fail) {
          return ("<article class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h2>" + (fail ? this.cross : this.tick) + heading + "</h2><div>");
        };
        this.articleFoot = '</div></article>';
        this.sectionHead = function(heading, fail) {
          return ("<section class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h3>" + (fail ? this.cross : this.tick) + heading + "</h3><div>");
        };
        this.sectionFoot = '</div></section>';
        this.jobFormat = function(heading, result) {
          return ("<div class=\"" + (result ? 'fail' : 'pass') + "\">") + ("<h4>" + (result ? this.cross : this.tick) + heading + "</h4>") + ("" + (result ? this.formatError(result) : '')) + "</div>";
        };
        this.tick = '<b class="pass">\u2713</b> ';
        this.cross = '<b class="fail">\u2718</b> ';
        break;
      default:
        this.pageHead = function(summary) {
          return "" + summary;
        };
        this.pageFoot = function(summary) {
          return "\n" + summary;
        };
        this.articleHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n===" + (new Array(heading.length).join('=')) + "\n";
        };
        this.articleFoot = '';
        this.sectionHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n---" + (new Array(heading.length).join('-')) + "\n";
        };
        this.sectionFoot = '';
        this.jobFormat = function(heading, result) {
          return ((result ? this.cross : this.tick) + " " + heading) + ("" + (result ? '\n' + this.formatError(result) : ''));
        };
        this.jobFoot = '';
        this.tick = '\u2713';
        this.cross = '\u2718';
    }
  }

  Tudor.prototype.add = function(lines) {
    var article, i, line, runner, section;
    article = {
      sections: []
    };
    runner = null;
    section = null;
    if (_o.A !== _o.type(lines)) {
      throw Error("`lines` isn’t an array");
    }
    if (0 === lines.length) {
      throw Error("`lines` has no elements");
    }
    if (_o.S !== _o.type(lines[0])) {
      throw Error("`lines[0]` isn’t a string");
    }
    article.heading = lines.shift();
    i = 0;
    while (i < lines.length) {
      line = lines[i];
      switch (_o.type(line)) {
        case _o.O:
          if (!line.runner) {
            throw new Error("Errant object");
          }
          runner = line.runner;
          break;
        case _o.F:
          section.jobs.push(line);
          break;
        case _o.S:
          if (this.isAssertion(lines[i + 1], lines[i + 2])) {
            if (!section) {
              throw new Error("Cannot add an assertion here");
            }
            section.jobs.push([runner, line, lines[++i], lines[++i]]);
          } else {
            section = {
              heading: line,
              jobs: []
            };
            article.sections.push(section);
          }
      }
      i++;
    }
    return this.articles.push(article);
  };

  Tudor.prototype["do"] = function() {
    var actual, art, artFail, artPass, article, e, error, expect, heading, j, job, k, l, len, len1, len2, mock, mockFail, pge, pgeFail, pgePass, ref, ref1, ref2, result, runner, sec, secFail, secPass, section, summary;
    pge = [];
    mock = [];
    pgePass = pgeFail = mockFail = 0;
    ref = this.articles;
    for (j = 0, len = ref.length; j < len; j++) {
      article = ref[j];
      art = [];
      artPass = artFail = 0;
      ref1 = article.sections;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        section = ref1[k];
        sec = [];
        secPass = secFail = 0;
        ref2 = section.jobs;
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          job = ref2[l];
          switch (_o.type(job)) {
            case _o.F:
              try {
                mock = job.apply(this, mock);
              } catch (_error) {
                e = _error;
                error = e.message;
              }
              if (error) {
                mockFail++;
                secFail++;
                sec.push(this.formatMockModifierError(job, error));
              }
              break;
            case _o.A:
              runner = job[0], heading = job[1], expect = job[2], actual = job[3];
              result = runner(expect, actual, mock);
              if (!result) {
                sec.push(this.jobFormat("" + (this.sanitize(heading))));
                pgePass++;
                artPass++;
                secPass++;
              } else {
                sec.push(this.jobFormat("" + (this.sanitize(heading)), result));
                pgeFail++;
                artFail++;
                secFail++;
              }
          }
        }
        sec.unshift(this.sectionHead("" + (this.sanitize(section.heading)), secFail));
        sec.push(this.sectionFoot);
        art = art.concat(sec);
      }
      art.unshift(this.articleHead("" + (this.sanitize(article.heading)), artFail));
      art.push(this.articleFoot);
      pge = pge.concat(art);
      summary = pgeFail ? this.cross + " FAILED " + pgeFail + "/" + (pgePass + pgeFail) : this.tick + " Passed " + pgePass + "/" + (pgePass + pgeFail);
      if (mockFail) {
        summary = "\n" + this.cross + " (MOCK FAILS)";
      }
    }
    pge.unshift(this.pageHead(summary));
    pge.push(this.pageFoot(summary));
    return pge.join('\n');
  };

  Tudor.prototype.formatError = function(result) {
    switch (result.length + "-" + this.opt.format) {
      case '2-html':
        return result[0] + "\n<pre class=\"fail\">" + (this.sanitize(result[1].message)) + "</pre>";
      case '2-plain':
        return result[0] + "\n" + (this.sanitize(result[1].message));
      case '3-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + "</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + "</pre>";
      case '3-plain':
        return (this.sanitize(this.reveal(result[0]))) + "\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2])));
      case '4-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + " (" + (_o.type(result[0])) + ")</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + " (" + (_o.type(result[2])) + ")</pre>";
      case '4-plain':
        return (this.sanitize(this.reveal(result[0]))) + " (" + (_o.type(result[0])) + ")\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2]))) + " (" + (_o.type(result[2])) + ")";
      default:
        throw new Error("Cannot process '" + result.length + "-" + this.opt.format + "'");
    }
  };

  Tudor.prototype.formatMockModifierError = function(fn, error) {
    switch (this.opt.format) {
      case 'html':
        return "<pre class=\"fn\">" + (this.sanitize(fn + '')) + "</pre>\n...encountered an exception:\n<pre class=\"fail\">" + (this.sanitize(error)) + "</pre>";
      default:
        return (this.sanitize(fn + '')) + "\n...encountered an exception:\n" + (this.sanitize(error));
    }
  };

  Tudor.prototype.reveal = function(value) {
    return value != null ? value.toString().replace(/^\s+|\s+$/g, function(match) {
      return '\u00b7' + (new Array(match.length)).join('\u00b7');
    }) : void 0;
  };

  Tudor.prototype.sanitize = function(value) {
    switch (this.opt.format) {
      case 'html':
        return value != null ? value.toString().replace(/</g, '&lt;') : void 0;
      default:
        return value;
    }
  };

  Tudor.prototype["throw"] = {
    runner: function(expect, actual, mock) {
      var e, error;
      if (mock == null) {
        mock = [];
      }
      error = false;
      try {
        actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (!error) {
        return [
          'No exception thrown, expected', {
            message: expect
          }
        ];
      } else if (expect !== error.message) {
        return [error.message, 'was thrown, but expected', expect];
      }
    }
  };

  Tudor.prototype.equal = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      if (mock == null) {
        mock = [];
      }
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== result) {
        if (result + '' === expect + '') {
          return [result, 'was returned, but expected', expect, true];
        } else {
          return [result, 'was returned, but expected', expect];
        }
      }
    }
  };

  Tudor.prototype.is = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      if (mock == null) {
        mock = [];
      }
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== _o.type(result)) {
        return ["type " + (_o.type(result)), 'was returned, but expected', "type " + expect];
      }
    }
  };

  Tudor.prototype.match = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      if (mock == null) {
        mock = [];
      }
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (_o.F !== typeof expect.test) {
        return [
          '`test()` is not a function', {
            message: expect
          }
        ];
      } else if (!expect.test('' + result)) {
        return ['' + result, 'failed test', expect];
      }
    }
  };

  Tudor.prototype.isAssertion = function(line1, line2) {
    if (_o.F !== _o.type(line2)) {
      return false;
    }
    if ((_o.O === _o.type(line1)) && _o.F === _o.type(line1.runner)) {
      return false;
    }
    return true;
  };

  return Tudor;

})();

tudor = new Tudor({
  format: _o.O === typeof window ? 'html' : 'plain'
});

Ldc.runTest = tudor["do"];

tudor.add([
  "01 Ldc Constructor", tudor.is, "The class and instance are expected types", "The Ldc class is a function", _o.F, function() {
    return Ldc;
  }, "`new` returns an object", _o.O, function() {
    return new Ldc;
  }, "Instance properties as expected", "`Ldc::items` is an array", _o.A, function() {
    return (new Ldc).items;
  }, tudor.equal, "`Ldc::items` is empty", 0, function() {
    return (new Ldc).items.length;
  }
]);

tudor.add([
  "02 Ldc::addItem()", tudor.is, "`addItem()` is a function which returns a string", function() {
    return [new Ldc];
  }, "`addItem()` is a function", _o.F, function(ldc) {
    return ldc.addItem;
  }, "`addItem('Hat')` returns a string", _o.S, function(ldc) {
    return ldc.addItem('Hat');
  }, "The `kind` argument accepts class-names as expected", tudor.equal, "'Hat' is a recognized class-name", 'Item.Hit.Hat', function(ldc) {
    ldc.addItem('Hat');
    return ldc.items[ldc.items.length - 1].C;
  }, "'Sine' is a recognized class-name", 'Item.Tone.Sine', function(ldc) {
    ldc.addItem('Sine');
    return ldc.items[ldc.items.length - 1].C;
  }, "`kind` exceptions", tudor["throw"], "`kind` not provided", "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  argument kind is undefined and has no fallback", function(ldc) {
    return ldc.addItem();
  }, "An array, not a string", "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  argument kind is type array not string", function(ldc) {
    return ldc.addItem(['H', 'a', 't']);
  }, "'Tone' is not a recognized class-name", "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  argument kind fails ^Hat$|^Sine$", function(ldc) {
    return ldc.addItem('Tone');
  }, "The `config` argument accepts an object as expected", tudor.equal, "An empty object", 4, function(ldc) {
    ldc.addItem('Hat', {});
    return ldc.items.length;
  }, "An object with arbitrary content", 5, function(ldc) {
    ldc.addItem('Hat', {
      a: 1,
      b: 2
    });
    return ldc.items.length;
  }, "Can be undefined", 6, function(ldc) {
    ldc.addItem('Hat', void 0);
    return ldc.items.length;
  }, "`config` exceptions", tudor["throw"], "A `Date` object", "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  argument config is type date not object", function(ldc) {
    return ldc.addItem('Hat', new Date());
  }, "Is the `null` object", "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  argument config is type null not object", function(ldc) {
    return ldc.addItem('Hat', null);
  }, "The `uid` argument accepts a string as expected", tudor.equal, "Shortest possible uid", 7, function(ldc) {
    ldc.addItem('Hat', void 0, 'aB');
    return ldc.items.length;
  }, "Longest possible uid", 'abcdefghijklmnopqrst123_', function(ldc) {
    return ldc.addItem('Hat', {}, 'abcdefghijklmnopqrst123_');
  }, "Can repeat existing uid, if case is different", 9, function(ldc) {
    ldc.addItem('Hat', {}, 'aBcDeFgHiJkLmNoPqRsT123_');
    return ldc.items.length;
  }, "`uid` exceptions", tudor["throw"], "Is boolean", "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  argument uid is type boolean not string", function(ldc) {
    return ldc.addItem('Hat', {}, true);
  }, "Empty string", "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  argument uid fails ^[a-z]\\w{1,23}$", function(ldc) {
    return ldc.addItem('Hat', {}, '');
  }, "Too short", "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  argument uid fails ^[a-z]\\w{1,23}$", function(ldc) {
    return ldc.addItem('Hat', {}, 'a');
  }, "Too long", "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  argument uid fails ^[a-z]\\w{1,23}$", function(ldc) {
    return ldc.addItem('Hat', {}, 'aBcDeFgHiJkLmNoPqRsT123_X');
  }, "Underscore is an invalid first character", "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  argument uid fails ^[a-z]\\w{1,23}$", function(ldc) {
    return ldc.addItem('Hat', {}, '_abc');
  }, "Number is an invalid first character", "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  argument uid fails ^[a-z]\\w{1,23}$", function(ldc) {
    return ldc.addItem('Hat', {}, '1abc');
  }, "Uppercase is an invalid first character", "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  argument uid fails ^[a-z]\\w{1,23}$", function(ldc) {
    return ldc.addItem('Hat', {}, 'Abc');
  }, "Must not contain a hyphen", "/ldc/src/Ldc.litcoffee Ldc::addItem()\n  argument uid fails ^[a-z]\\w{1,23}$", function(ldc) {
    return ldc.addItem('Hat', {}, 'ab-c');
  }
]);

tudor.add([
  "03 Item Constructor", tudor.is, "The class and instance are expected types", "The Item class is a function", _o.F, function() {
    return Item;
  }, "`new` returns an object", _o.O, function() {
    return new Item({
      uid: 'abc',
      index: 0
    });
  }, "Instance properties as expected", "`Item::uid` is a string", _o.S, function() {
    return (new Item({
      uid: 'abc',
      index: 0
    })).uid;
  }, "`Item::index` is a number", _o.N, function() {
    return (new Item({
      uid: 'abc',
      index: 0
    })).index;
  }, tudor.equal, "`Item::uid` is as passed-in", 'abc', function() {
    return (new Item({
      uid: 'abc',
      index: 0
    })).uid;
  }, "`Item::index` is as passed-in", 55, function() {
    return (new Item({
      uid: 'abc',
      index: 55
    })).index;
  }, "`config.uid` exceptions", tudor["throw"], "No `config.uid`", "/ldc/src/Item.litcoffee Item()\n  config.uid is undefined and has no fallback", function() {
    return new Item({
      index: 0
    });
  }, "Is boolean", "/ldc/src/Item.litcoffee Item()\n  config.uid is type boolean not string", function() {
    return new Item({
      uid: true,
      index: 0
    });
  }, "Empty string", "/ldc/src/Item.litcoffee Item()\n  config.uid fails ^[a-z]\\w{1,23}$", function() {
    return new Item({
      uid: '',
      index: 0
    });
  }, "Too short", "/ldc/src/Item.litcoffee Item()\n  config.uid fails ^[a-z]\\w{1,23}$", function() {
    return new Item({
      uid: 'a',
      index: 0
    });
  }, "Too long", "/ldc/src/Item.litcoffee Item()\n  config.uid fails ^[a-z]\\w{1,23}$", function() {
    return new Item({
      uid: 'aBcDeFgHiJkLmNoPqRsT123_X',
      index: 0
    });
  }, "Underscore is an invalid first character", "/ldc/src/Item.litcoffee Item()\n  config.uid fails ^[a-z]\\w{1,23}$", function() {
    return new Item({
      uid: '_abc',
      index: 0
    });
  }, "Number is an invalid first character", "/ldc/src/Item.litcoffee Item()\n  config.uid fails ^[a-z]\\w{1,23}$", function() {
    return new Item({
      uid: '1abc',
      index: 0
    });
  }, "Uppercase is an invalid first character", "/ldc/src/Item.litcoffee Item()\n  config.uid fails ^[a-z]\\w{1,23}$", function() {
    return new Item({
      uid: 'Abc',
      index: 0
    });
  }, "Must not contain a hyphen", "/ldc/src/Item.litcoffee Item()\n  config.uid fails ^[a-z]\\w{1,23}$", function() {
    return new Item({
      uid: 'ab-c',
      index: 0
    });
  }, "`config.index` exceptions", "No `config.index`", "/ldc/src/Item.litcoffee Item()\n  config.index is undefined and has no fallback", function() {
    return new Item({
      uid: 'abc'
    });
  }, "Is string", "/ldc/src/Item.litcoffee Item()\n  config.index is type string not integer", function() {
    return new Item({
      uid: 'abc',
      index: '3'
    });
  }, "Is not a whole number", "/ldc/src/Item.litcoffee Item()\n  config.index is a number but not an integer", function() {
    return new Item({
      uid: 'abc',
      index: 3.5
    });
  }, "Is negative", "/ldc/src/Item.litcoffee Item()\n  config.index is -1 (must be 0-9999)", function() {
    return new Item({
      uid: 'abc',
      index: -1
    });
  }, "Is too high", "/ldc/src/Item.litcoffee Item()\n  config.index is 9999999 (must be 0-9999)", function() {
    return new Item({
      uid: 'abc',
      index: 9999999
    });
  }
]);
}).call(this,this);
// Example vendor file. 
