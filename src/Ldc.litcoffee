Ldc
===

@todo describe


#### The main class for Ldc

    class Ldc
      C: 'Ldc'
      toString: -> '[object Ldc]'

      constructor: (config={}) ->
        M = "/ldc/src/Ldc.litcoffee
          Ldc()\n  "




Properties
----------


#### `items <object>`
Contains all Item instances currently held by this Ldc instance.  
See `browseItems()`, `readItem()`, `editItem()`, `addItem()` and `deleteItem()`.

        @items = {}


#### `items._length <integer>`
Keeps track of the number of Items currently held in `items`. 

        @items._length = 0


#### `items._first, items._last <Item|null>`
The Items first and most-recently added to `items`. `null` if `items` is empty. 

        @items._first = null
        @items._last  = null




Methods
-------


#### `addItem()`
- `kind <string>`    the class-name of the Item to create
- `config <object>`  (optional) configuration to pass to the Item’s constructor
- `id <string>`      (optional) a unique identifier (autogenerated, if missing)
- `<string>`         returns the newly-added item’s unique identifier

Instantiates a new Item, and records it in `items`. 

      addItem: (kind, config, id) ->
        M = "/ldc/src/Ldc.litcoffee
          Ldc::addItem()\n  "

Get a list of leaf-nodes in the `Item` class inheritance tree.  
@todo autogenerate `kinds`

        kinds = {
            Hat:  Item.Hit.Hat
          , Sine: Item.Tone.Sine
        }

Check that the arguments are ok, and that `id` is unique. 

        v = _o.validator M + 'argument ', { kind:kind, config:config, id:id }
        kind   = v 'kind <string ^' + Object.keys(kinds).join('$|^') + '$>'
        config = v 'config <object>', {} # classes validate config details
        id     = v 'id <string ^[a-z]\\w{1,23}$>', _o.uid(kind.toLowerCase())
        unless _o.isU @items[id] then throw RangeError M + "
          an Item with id '#{id}' already exists"

Fill in the `id`, `prev` and `next` config properties.  
@todo stop `prev` and `next` from providing refs to Item instances?

        config.id   = id
        config.prev = if @items._length then @items._last else null
        config.next = null

Create a new instance, and add it to `items`. 

        item = new kinds[kind](config) # throws an exception if `config` is bad
        if @items._length
          @items._last.next = item
        else
          @items._first = item
        @items._last = item
        @items[id] = item
        @items._length++

Return `id`, which was either passed in as an argument, or autogenerated. 

        return id




#### `deleteItem()`
- `id <string>`  the unique identifier of the Item instance to delete
- `<undefined>`  does not return anything

Removes all Item references, freeing it up for [gc](https://goo.gl/Lw16h1). 

      deleteItem: (id) ->
        M = "/ldc/src/Ldc.litcoffee
          Ldc::deleteItem()\n  "

Check that the `id` argument is ok. 

        v = _o.validator M + 'argument ', { id:id }
        v 'id <string ^[a-z]\\w{1,23}$>'
        item = @items[id]
        if _o.isU item then throw RangeError M + "
          the Item with id '#{id}' does not exist"

Update the previous and next Items in `items`. 

        if item.prev then item.prev.next = item.next
        if item.next then item.next.prev = item.prev

Update the `_length`, `_first` and `_last` properties. 

        @items._length--
        if !item.prev then @items._first = item.next
        if !item.next then @items._last  = item.prev

Delete the Item from `items` and return `undefined`. 

        delete @items[id]
        return undefined




#### `xx()`
- `yy <zz>`      @todo describe
- `<undefined>`  does not return anything

@todo describe

      xx: (yy) ->
        M = "/ldc/src/Ldc.litcoffee
          Ldc::xx()\n  "




Namespaced Functions
--------------------


#### `xx()`
- `yy <zz>`      @todo describe
- `<undefined>`  does not return anything

@todo describe

    Ldc.xx = (yy) ->
      M = "/ldc/src/Ldc.litcoffee
        Ldc.xx()\n  "




    ;
